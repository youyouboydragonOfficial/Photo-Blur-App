<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Creative Studio Ultimate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { touch-action: none; overscroll-behavior: none; }
        /* カスタムスクロールバー */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 overflow-hidden h-screen w-screen select-none">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- アイコンコンポーネント (Lucide Iconsの簡易実装) ---
        const Icons = {
            Upload: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
            Download: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
            Image: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>,
            Video: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>,
            Sliders: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/><line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/><line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/><line x1="1" y1="14" x2="7" y2="14"/><line x1="9" y1="8" x2="15" y2="8"/><line x1="17" y1="16" x2="23" y2="16"/></svg>,
            Play: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            Pause: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
            Trash2: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            ZoomIn: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
            ZoomOut: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
            Hand: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>,
            PenTool: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>,
            Undo: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>,
            Monitor: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>,
            Lock: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Unlock: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>
        };

        const Icon = ({ name, size = 20, className = "" }) => {
            const IconComponent = Icons[name] || Icons.Monitor;
            return <IconComponent width={size} height={size} className={className} />;
        };

        // --- UIパーツ ---
        const Button = ({ children, onClick, active, variant = "primary", disabled = false, title = "", className="" }) => {
            const baseStyle = "p-3 rounded-xl font-medium transition-all duration-200 flex items-center justify-center gap-2 select-none touch-none cursor-pointer";
            const variants = {
                primary: active 
                ? "bg-blue-600 text-white shadow-lg shadow-blue-500/30 scale-105 ring-2 ring-blue-400 ring-offset-2 ring-offset-slate-900" 
                : "bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white",
                danger: "bg-red-500/10 text-red-400 hover:bg-red-500 hover:text-white",
                secondary: "bg-slate-700 text-slate-300 hover:bg-slate-600 hover:text-white"
            };
            return (
                <button onClick={onClick} disabled={disabled} title={title} className={`${baseStyle} ${variants[variant]} ${disabled?'opacity-50 cursor-not-allowed':''} ${className}`}>
                {children}
                </button>
            );
        };

        const Slider = ({ label, value, min, max, onChange, unit = "", onInteractionStart, onInteractionEnd }) => (
            <div className="mb-4">
                <div className="flex justify-between mb-1.5">
                    <span className="text-[10px] font-bold text-slate-500 uppercase">{label}</span>
                    <span className="text-xs font-mono text-blue-400">{value}{unit}</span>
                </div>
                <input
                    type="range" min={min} max={max} value={value}
                    onChange={(e) => onChange(parseFloat(e.target.value))}
                    onPointerDown={onInteractionStart}
                    onPointerUp={onInteractionEnd}
                    onTouchStart={onInteractionStart}
                    onTouchEnd={onInteractionEnd}
                    className="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer accent-blue-500 touch-none"
                />
            </div>
        );

        // --- メインアプリ ---
        function App() {
            // === State ===
            const [file, setFile] = useState(null);
            const [fileType, setFileType] = useState(null); 
            const [mediaSrc, setMediaSrc] = useState(null);
            
            const [zoom, setZoom] = useState(1); 
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [originalSize, setOriginalSize] = useState({ w: 1280, h: 720 });
            
            const [mode, setMode] = useState('move'); 
            const [brushSize, setBrushSize] = useState(40);
            const [isResizingBrush, setIsResizingBrush] = useState(false);

            const [filters, setFilters] = useState({ brightness: 100, contrast: 100 });
            const [lines, setLines] = useState([]); 
            const [history, setHistory] = useState([]);

            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [isExporting, setIsExporting] = useState(false);
            const [exportProgress, setExportProgress] = useState(0);

            const canvasRef = useRef(null);
            const videoRef = useRef(null);
            const containerRef = useRef(null);
            const requestRef = useRef(null);
            
            const isDragging = useRef(false);
            const lastPos = useRef({ x: 0, y: 0 });
            const currentLine = useRef(null); 

            // === ファイル処理 ===
            const handleFileUpload = (e) => {
                const f = e.target.files[0];
                if (!f) return;
                const url = URL.createObjectURL(f);
                
                setFile(f);
                setMediaSrc(url);
                setLines([]);
                setHistory([]);
                setFilters({ brightness: 100, contrast: 100 });
                setPan({ x: 0, y: 0 });
                setIsPlaying(false);
                setMode('move'); 
                
                if (f.type.startsWith('image/')) {
                setFileType('image');
                const img = new Image();
                img.onload = () => {
                    setOriginalSize({ w: img.width, h: img.height });
                    fitToScreen(img.width, img.height);
                };
                img.src = url;
                } else if (f.type.startsWith('video/')) {
                setFileType('video');
                }
            };

            const onVideoLoaded = () => {
                if (videoRef.current) {
                const v = videoRef.current;
                setDuration(v.duration);
                setOriginalSize({ w: v.videoWidth, h: v.videoHeight });
                fitToScreen(v.videoWidth, v.videoHeight);
                }
            };

            const fitToScreen = (w, h) => {
                if (!containerRef.current) return;
                const cw = containerRef.current.clientWidth;
                const ch = containerRef.current.clientHeight;
                const scale = Math.min((cw - 40) / w, (ch - 40) / h, 1);
                setZoom(scale);
                setPan({ 
                    x: (cw - w * scale) / 2, 
                    y: (ch - h * scale) / 2 
                });
            };

            // === 描画 ===
            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });

                if (canvas.width !== originalSize.w || canvas.height !== originalSize.h) {
                canvas.width = originalSize.w;
                canvas.height = originalSize.h;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.filter = `brightness(${filters.brightness}%) contrast(${filters.contrast}%)`;
                if (fileType === 'image') {
                    const img = new Image();
                    img.src = mediaSrc;
                    if (img.complete) ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                } else if (fileType === 'video' && videoRef.current) {
                    ctx.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);
                }
                ctx.filter = 'none';

                if (lines.length > 0) {
                    const mosaicScale = 0.05; 
                    const mw = Math.ceil(canvas.width * mosaicScale);
                    const mh = Math.ceil(canvas.height * mosaicScale);
                    
                    const offCanvas = document.createElement('canvas');
                    offCanvas.width = mw;
                    offCanvas.height = mh;
                    const offCtx = offCanvas.getContext('2d');
                    offCtx.drawImage(canvas, 0, 0, mw, mh);

                    const maskCanvas = document.createElement('canvas');
                    maskCanvas.width = canvas.width;
                    maskCanvas.height = canvas.height;
                    const maskCtx = maskCanvas.getContext('2d');
                    maskCtx.lineCap = 'round';
                    maskCtx.lineJoin = 'round';
                    maskCtx.strokeStyle = 'red'; 
                    
                    lines.forEach(line => {
                        if (!line || !line.points || line.points.length === 0) return;
                        maskCtx.lineWidth = line.size;
                        maskCtx.beginPath();
                        maskCtx.moveTo(line.points[0].x, line.points[0].y);
                        for(let i=1; i<line.points.length; i++) maskCtx.lineTo(line.points[i].x, line.points[i].y);
                        maskCtx.stroke();
                    });

                    ctx.save();
                    
                    const mosaicFullCanvas = document.createElement('canvas');
                    mosaicFullCanvas.width = canvas.width;
                    mosaicFullCanvas.height = canvas.height;
                    const mCtx = mosaicFullCanvas.getContext('2d');
                    mCtx.imageSmoothingEnabled = false; 
                    mCtx.drawImage(offCanvas, 0, 0, mw, mh, 0, 0, canvas.width, canvas.height);

                    mCtx.globalCompositeOperation = 'destination-in';
                    mCtx.drawImage(maskCanvas, 0, 0);

                    ctx.drawImage(mosaicFullCanvas, 0, 0);
                    ctx.restore();
                }
            }, [originalSize, fileType, mediaSrc, filters, lines, videoRef]);

            useEffect(() => {
                if (fileType === 'video' && isPlaying) {
                const loop = () => {
                    draw();
                    requestRef.current = requestAnimationFrame(loop);
                };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
                } else {
                requestAnimationFrame(draw);
                }
            }, [isPlaying, draw, fileType]);

            // === ポインター処理 ===
            const getPointerPos = (e) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                const cx = e.clientX - rect.left;
                const cy = e.clientY - rect.top;
                const x = (cx - pan.x) / zoom;
                const y = (cy - pan.y) / zoom;
                return { x, y };
            };

            const handlePointerDown = (e) => {
                if (!file) return;
                e.preventDefault(); 
                e.stopPropagation();
                e.currentTarget.setPointerCapture(e.pointerId);

                isDragging.current = true;
                lastPos.current = { x: e.clientX, y: e.clientY };

                if (mode === 'brush') {
                const pos = getPointerPos(e);
                const newLine = {
                    points: [{ x: pos.x, y: pos.y }],
                    size: brushSize
                };
                currentLine.current = newLine;
                setLines(prev => [...prev, newLine]);
                setHistory(prev => [...prev, lines]);
                }
            };

            const handlePointerMove = (e) => {
                if (!isDragging.current) return;
                e.preventDefault();
                e.stopPropagation();

                if (mode === 'brush') {
                    const pos = getPointerPos(e);
                    if (currentLine.current) {
                        currentLine.current.points.push({ x: pos.x, y: pos.y });
                        const updatedLine = { ...currentLine.current };
                        setLines(prev => {
                            const next = [...prev];
                            if (next.length > 0) next[next.length - 1] = updatedLine;
                            return next;
                        });
                    }
                } else if (mode === 'move') {
                    const dx = e.clientX - lastPos.current.x;
                    const dy = e.clientY - lastPos.current.y;
                    setPan(p => ({ x: p.x + dx, y: p.y + dy }));
                    lastPos.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handlePointerUp = (e) => {
                isDragging.current = false;
                currentLine.current = null;
                if(e.currentTarget.hasPointerCapture(e.pointerId)) {
                e.currentTarget.releasePointerCapture(e.pointerId);
                }
            };

            const handleUndo = () => {
                if (history.length > 0) {
                const prevLines = history[history.length - 1];
                setLines(prevLines);
                setHistory(prev => prev.slice(0, -1));
                } else if (lines.length > 0) {
                setLines([]);
                }
            };

            const handleExport = async () => {
                setIsExporting(true);
                await new Promise(r => setTimeout(r, 100));
                draw(); 
                
                if (fileType === 'image') {
                    const link = document.createElement('a');
                    link.download = `edited_${Date.now()}.png`;
                    link.href = canvasRef.current.toDataURL('image/png', 1.0);
                    link.click();
                    setIsExporting(false);
                } else {
                    const stream = canvasRef.current.captureStream(30);
                    const recorder = new MediaRecorder(stream, { 
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 8000000 
                    });
                    const chunks = [];
                    recorder.ondataavailable = e => chunks.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, {type:'video/webm'});
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `movie_${Date.now()}.webm`;
                        a.click();
                        setIsExporting(false);
                        setIsPlaying(false);
                    };
                    
                    videoRef.current.currentTime = 0;
                    videoRef.current.play();
                    setIsPlaying(true);
                    recorder.start();
                    
                    const check = setInterval(() => {
                        if(videoRef.current.ended) {
                        recorder.stop();
                        clearInterval(check);
                        } else {
                        setExportProgress((videoRef.current.currentTime/duration)*100);
                        draw();
                        }
                    }, 50);
                }
            };

            // === レンダリング ===
            return (
                <div className="flex h-screen bg-slate-950 text-slate-100 overflow-hidden select-none touch-none font-sans">
                
                {/* サイドバー */}
                <div className="w-16 sm:w-20 bg-slate-900 border-r border-slate-800 flex flex-col items-center py-6 gap-4 sm:gap-6 z-20 shadow-xl">
                    <div className="p-3 bg-blue-600 rounded-xl shadow-lg shadow-blue-500/20 mb-2">
                        <Icon name="Monitor" className="text-white" size={24}/>
                    </div>
                    
                    <div className="flex flex-col gap-3 w-full px-1 sm:px-2">
                        <Button 
                            variant="primary" 
                            active={mode === 'move'} 
                            onClick={() => setMode('move')} 
                            title="移動モード (画像を動かす)"
                        >
                            <div className="flex flex-col items-center gap-1">
                                {mode === 'move' ? <Icon name="Unlock" className="text-green-400" size={24}/> : <Icon name="Hand" size={24}/>}
                                <span className="text-[9px] sm:text-[10px] font-bold">移動</span>
                            </div>
                        </Button>

                        <Button 
                            variant="primary" 
                            active={mode === 'brush'} 
                            onClick={() => setMode('brush')} 
                            title="お絵描きモード (画像固定)"
                        >
                            <div className="flex flex-col items-center gap-1">
                                {mode === 'brush' ? <Icon name="Lock" className="text-red-400" size={24}/> : <Icon name="PenTool" size={24}/>}
                                <span className="text-[9px] sm:text-[10px] font-bold">描く</span>
                            </div>
                        </Button>
                    </div>

                    <div className="w-8 h-px bg-slate-800 my-2"></div>

                    <Button variant="secondary" onClick={handleUndo} title="ひとつ戻る">
                        <Icon name="Undo" size={24}/>
                    </Button>
                    
                    <div className="mt-auto">
                        <Button variant="danger" onClick={() => setLines([])} title="全消去">
                            <Icon name="Trash2" size={24}/>
                        </Button>
                    </div>
                </div>

                {/* メインエリア */}
                <div className="flex-1 flex flex-col relative bg-[#1e293b]">
                    {/* ヘッダー */}
                    <header className="h-14 sm:h-16 px-4 sm:px-6 border-b border-slate-800 flex items-center justify-between bg-slate-900 shadow-md z-10">
                        <div className="flex flex-col">
                            <h1 className="font-bold text-base sm:text-lg text-slate-200">Creative Studio <span className="text-blue-400 font-light">Pro</span></h1>
                            <p className="text-[10px] text-slate-400 hidden sm:block">
                                {mode === 'brush' 
                                    ? <span className="text-red-400 font-bold flex items-center gap-1">画像ロック中：お絵描きできます</span> 
                                    : <span className="text-green-400 font-bold flex items-center gap-1">移動モード：位置調整やズームができます</span>}
                            </p>
                        </div>
                        
                        <div className="flex gap-2 sm:gap-4">
                            <label className="flex items-center gap-2 bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded-lg cursor-pointer transition-colors border border-slate-700 shadow-sm">
                                <Icon name="Upload" className="text-blue-400" size={18}/>
                                <span className="text-xs sm:text-sm font-medium">アップロード</span>
                                <input type="file" accept="image/*,video/*" className="hidden" onChange={handleFileUpload} />
                            </label>
                            
                            {file && (
                                <Button variant="primary" onClick={handleExport} disabled={isExporting} className="!px-3 !py-2">
                                    {isExporting ? `処理中...` : <><Icon name="Download" size={18}/><span className="hidden sm:inline text-sm">保存</span></>}
                                </Button>
                            )}
                        </div>
                    </header>

                    {/* キャンバスエリア */}
                    <div className="flex-1 relative overflow-hidden bg-[#0f172a] touch-none">
                        {!file ? (
                            <div className="absolute inset-0 flex flex-col items-center justify-center opacity-30 pointer-events-none select-none">
                                <Icon name="Image" size={64} className="mb-4"/>
                                <p className="text-lg sm:text-xl font-bold">ファイルをドロップ</p>
                            </div>
                        ) : (
                            <div 
                                ref={containerRef}
                                className="w-full h-full relative overflow-hidden touch-none"
                                style={{ 
                                    cursor: mode === 'move' ? 'grab' : 'crosshair',
                                    touchAction: 'none'
                                }}
                                onPointerDown={handlePointerDown}
                                onPointerMove={handlePointerMove}
                                onPointerUp={handlePointerUp}
                                onPointerLeave={handlePointerUp}
                            >
                                <canvas 
                                    ref={canvasRef}
                                    className="absolute origin-top-left shadow-2xl shadow-black pointer-events-none select-none"
                                    style={{ 
                                        transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                                        imageRendering: 'pixelated' 
                                    }}
                                />
                                
                                {/* ブラシサイズ・プレビュー表示 */}
                                {isResizingBrush && (
                                    <div 
                                        className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 border-white bg-red-500/30 z-50 pointer-events-none shadow-lg shadow-black/50 transition-all"
                                        style={{
                                            width: brushSize * zoom,
                                            height: brushSize * zoom,
                                        }}
                                    >
                                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white text-xs font-bold drop-shadow-md whitespace-nowrap">
                                            {Math.round(brushSize)}px
                                        </div>
                                    </div>
                                )}

                                {mode === 'brush' && (
                                    <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-red-500/90 text-white px-4 py-1 rounded-full text-xs font-bold shadow-lg pointer-events-none animate-pulse z-50 flex items-center gap-2 border border-white/20">
                                        <Icon name="Lock" size={12}/> 画像固定中
                                    </div>
                                )}

                                <video 
                                    ref={videoRef} src={mediaSrc} 
                                    className="hidden" 
                                    onLoadedMetadata={onVideoLoaded}
                                    onTimeUpdate={() => setCurrentTime(videoRef.current.currentTime)}
                                    onEnded={() => setIsPlaying(false)}
                                    muted={isExporting}
                                    playsInline
                                />
                            </div>
                        )}
                    </div>

                    {/* 動画コントロール */}
                    {fileType === 'video' && (
                        <div className="h-16 bg-slate-900 border-t border-slate-800 flex items-center px-4 gap-4 z-10">
                            <button onClick={() => {
                                if(videoRef.current) isPlaying ? videoRef.current.pause() : videoRef.current.play();
                                setIsPlaying(!isPlaying);
                            }} className="p-2 bg-slate-100 text-slate-900 rounded-full hover:bg-white shadow">
                                {isPlaying ? <Icon name="Pause" size={20}/> : <Icon name="Play" size={20}/>}
                            </button>
                            <input 
                                type="range" min="0" max={duration||100} step="0.1" 
                                value={currentTime}
                                onChange={(e)=>{
                                    const t=parseFloat(e.target.value);
                                    setCurrentTime(t);
                                    if(videoRef.current) videoRef.current.currentTime=t;
                                    draw();
                                }}
                                className="flex-1 h-2 bg-slate-700 rounded-lg accent-blue-500 cursor-pointer"
                            />
                        </div>
                    )}
                </div>

                {/* 右サイドバー (設定) */}
                {file && (
                    <div className="w-64 sm:w-72 bg-slate-900 border-l border-slate-800 p-4 sm:p-5 flex flex-col gap-6 overflow-y-auto z-20 shadow-xl">
                        
                        <div className="p-3 sm:p-4 bg-slate-800/50 rounded-xl border border-slate-700">
                            <h3 className="text-xs font-bold text-slate-400 mb-3 flex items-center gap-2 uppercase">
                                <Icon name="PenTool" size={14} className="text-red-400"/> ぼかしサイズ
                            </h3>
                            <Slider 
                                label="" 
                                value={brushSize} min={10} max={200} 
                                onChange={setBrushSize} unit="px"
                                onInteractionStart={() => setIsResizingBrush(true)}
                                onInteractionEnd={() => setIsResizingBrush(false)}
                            />
                            <div 
                                className="h-2 bg-red-400 rounded-full mx-auto transition-all" 
                                style={{ width: brushSize, maxWidth: '100%' }}
                            />
                            <p className="text-[10px] text-slate-500 mt-2">
                                バー操作中、画面中央に実際のサイズが出ます。
                            </p>
                        </div>

                        <div className="p-3 sm:p-4 bg-slate-800/50 rounded-xl border border-slate-700">
                            <h3 className="text-xs font-bold text-slate-400 mb-3 flex items-center gap-2 uppercase">
                                <Icon name="ZoomIn" size={14} className="text-green-400"/> ズーム
                            </h3>
                            <div className="flex gap-2 mb-2">
                                <Button onClick={() => setZoom(z => z + 0.1)} className="flex-1"><Icon name="ZoomIn" size={16}/></Button>
                                <Button onClick={() => setZoom(z => Math.max(0.1, z - 0.1))} className="flex-1"><Icon name="ZoomOut" size={16}/></Button>
                            </div>
                            <Button onClick={() => fitToScreen(originalSize.w, originalSize.h)} className="w-full text-xs" variant="secondary">全体表示</Button>
                        </div>

                        <div className="p-3 sm:p-4 bg-slate-800/50 rounded-xl border border-slate-700">
                            <h3 className="text-xs font-bold text-slate-400 mb-3 flex items-center gap-2 uppercase">
                                <Icon name="Sliders" size={14} className="text-blue-400"/> 画質調整
                            </h3>
                            <Slider label="明るさ" value={filters.brightness} min={0} max={200} onChange={v=>setFilters({...filters, brightness:v})} unit="%"/>
                            <Slider label="コントラスト" value={filters.contrast} min={0} max={200} onChange={v=>setFilters({...filters, contrast:v})} unit="%"/>
                        </div>
                        
                    </div>
                )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
